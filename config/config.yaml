# Configuration
# Configuration for Comprehensive Testing Framework

# Environment Configuration
environment: development

# Database Configurations
database:
  type: postgresql
  host: localhost
  port: 5432
  name: qa_testing_db
  user: qa_user
  password: qa_password
  echo: false

databases:
  postgresql:
    type: postgresql
    host: localhost
    port: 5432
    name: qa_testing_db
    user: qa_user
    password: qa_password
    echo: false
  
  mysql:
    type: mysql
    host: localhost
    port: 3306
    name: qa_testing_db
    user: qa_user
    password: qa_password
    echo: false
  
  sqlite:
    type: sqlite
    path: ./data/test.db
    echo: false

# API Configuration
api:
  base_url: http://localhost:8000
  timeout: 30
  retries: 3
  auth_type: bearer
  token: test_token_123

apis:
  data_api:
    base_url: http://localhost:8000/api/v1
    timeout: 30
    auth_type: bearer
    token: data_api_token
  
  analytics_api:
    base_url: http://localhost:8001/api/v1
    timeout: 60
    auth_type: api_key
    api_key: analytics_key_456

# Data Quality Thresholds
quality_thresholds:
  completeness_threshold: 95.0
  accuracy_threshold: 95.0
  anomaly_threshold: 5.0
  consistency_threshold: 90.0
  uniqueness_threshold: 98.0
  validity_threshold: 95.0

# Performance Thresholds
performance_thresholds:
  query_performance_threshold: 80.0
  load_test_threshold: 85.0
  stress_test_threshold: 70.0
  benchmark_threshold: 90.0
  response_time_threshold: 2.0
  throughput_threshold: 100.0

# API Testing Thresholds
api_thresholds:
  api_test_threshold: 85.0
  response_time_threshold: 2.0
  error_rate_threshold: 5.0
  availability_threshold: 99.9

# Kafka Configuration
kafka:
  bootstrap_servers: localhost:9092
  topic_prefix: qa_testing
  consumer_group: qa_consumer_group
  producer_config:
    acks: all
    retries: 3
  consumer_config:
    auto_offset_reset: earliest
    enable_auto_commit: false

# Redis Configuration
redis:
  url: redis://localhost:6379
  db: 0
  password: null
  max_connections: 10

# Logging Configuration
logging:
  level: INFO
  format: json
  file: logs/qa_engineer.log
  max_size: 100MB
  backup_count: 5
  console_output: true

# Test Data Configuration
test_data:
  sample_size: 10000
  data_generators:
    users:
      count: 1000
      fields:
        id: auto_increment
        name: faker.name
        email: faker.email
        created_at: faker.date_time
    
    orders:
      count: 5000
      fields:
        id: auto_increment
        user_id: foreign_key(users.id)
        amount: faker.random_number
        status: choice(['pending', 'completed', 'cancelled'])
        created_at: faker.date_time

# Schema Validation Rules
schema_validation:
  users:
    required_fields: [id, name, email, created_at]
    field_types:
      id: integer
      name: string
      email: string
      created_at: datetime
    constraints:
      email: email_format
      name: not_empty
  
  orders:
    required_fields: [id, user_id, amount, status, created_at]
    field_types:
      id: integer
      user_id: integer
      amount: decimal
      status: string
      created_at: datetime
    constraints:
      amount: positive_number
      status: enum(['pending', 'completed', 'cancelled'])

# Data Quality Rules
data_quality_rules:
  completeness_rules:
    users_email_required:
      column: email
      max_null_percentage: 0
    users_name_required:
      column: name
      max_null_percentage: 0
  
  accuracy_rules:
    order_amount_positive:
      type: range
      column: amount
      min: 0
    user_email_format:
      type: pattern
      column: email
      pattern: "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"
  
  uniqueness_rules:
    user_email_unique:
      type: unique
      column: email

# Performance Test Queries
performance_testing:
  queries:
    user_analysis:
      name: "User Analysis Query"
      sql: "SELECT COUNT(*), AVG(amount) FROM users u JOIN orders o ON u.id = o.user_id GROUP BY u.status"
      expected_time: 1.0
    
    order_summary:
      name: "Order Summary Query"
      sql: "SELECT status, COUNT(*), SUM(amount) FROM orders GROUP BY status"
      expected_time: 0.5
    
    complex_join:
      name: "Complex Join Query"
      sql: "SELECT u.name, COUNT(o.id), AVG(o.amount) FROM users u LEFT JOIN orders o ON u.id = o.user_id WHERE o.created_at >= NOW() - INTERVAL '30 days' GROUP BY u.id, u.name HAVING COUNT(o.id) > 0 ORDER BY AVG(o.amount) DESC LIMIT 100"
      expected_time: 2.0

# Load Testing Scenarios
load_testing:
  scenarios:
    normal_load:
      name: "Normal Load Scenario"
      concurrent_users: 10
      duration: 300
      requests_per_second: 10
    
    high_load:
      name: "High Load Scenario"
      concurrent_users: 50
      duration: 600
      requests_per_second: 50
    
    peak_load:
      name: "Peak Load Scenario"
      concurrent_users: 100
      duration: 300
      requests_per_second: 100

# API Endpoints for Testing
api_endpoints:
  - name: "Get Users"
    path: "/api/users"
    method: "GET"
    expected_status: 200
    headers:
      Content-Type: application/json
  
  - name: "Get User by ID"
    path: "/api/users/{id}"
    method: "GET"
    expected_status: 200
    params:
      id: 1
  
  - name: "Create User"
    path: "/api/users"
    method: "POST"
    expected_status: 201
    data:
      name: "Test User"
      email: "test@example.com"
  
  - name: "Get Orders"
    path: "/api/orders"
    method: "GET"
    expected_status: 200
  
  - name: "Create Order"
    path: "/api/orders"
    method: "POST"
    expected_status: 201
    data:
      user_id: 1
      amount: 100.50
      status: "pending"

# Security Testing Configuration
security_testing:
  sql_injection_payloads:
    - "' OR '1'='1"
    - "'; DROP TABLE users; --"
    - "' UNION SELECT * FROM users --"
  
  xss_payloads:
    - "<script>alert('XSS')</script>"
    - "javascript:alert('XSS')"
    - "<img src=x onerror=alert('XSS')>"
  
  authentication_tests:
    - test_name: "Valid Authentication"
      auth_type: "valid"
      expected_status: 200
    
    - test_name: "Invalid Authentication"
      auth_type: "invalid"
      expected_status: 401
    
    - test_name: "No Authentication"
      auth_type: "none"
      expected_status: 401

# Monitoring Configuration
monitoring:
  prometheus:
    enabled: true
    port: 9090
    metrics_path: /metrics
  
  grafana:
    enabled: true
    url: http://localhost:3000
    username: admin
    password: admin
  
  alerting:
    enabled: true
    slack_webhook: ""
    email_notifications: false

# CI/CD Integration
ci_cd:
  jenkins:
    enabled: false
    url: ""
    job_name: "qa-data-engineer-tests"
  
  github_actions:
    enabled: true
    workflow_file: .github/workflows/qa-tests.yml
  
  quality_gates:
    test_coverage_threshold: 90
    performance_threshold: 85
    security_score_threshold: 95

# Report Configuration
reporting:
  output_format: html
  output_directory: reports
  include_charts: true
  include_details: true
  email_reports: false
  email_recipients: []

# Test Execution Configuration
test_execution:
  parallel_execution: true
  max_workers: 4
  timeout: 300
  retry_failed_tests: true
  max_retries: 3
  stop_on_failure: false

# Data Pipeline Testing
pipeline_testing:
  etl_jobs:
    - name: "User Data Pipeline"
      source: "raw_users"
      target: "processed_users"
      validation_rules:
        - "row_count_should_increase"
        - "no_duplicate_emails"
        - "all_required_fields_present"
    
    - name: "Order Data Pipeline"
      source: "raw_orders"
      target: "processed_orders"
      validation_rules:
        - "row_count_should_increase"
        - "amount_should_be_positive"
        - "user_id_should_exist"

# Backup and Recovery Configuration
backup_recovery:
  enabled: true
  backup_schedule: "0 2 * * *"  # Daily at 2 AM
  backup_retention_days: 30
  backup_location: "./backups"
  test_restore: true 
